#include <vector>
#include <string>
#include <map>
#include <iostream>

using namespace std;
struct SA {
    //вектор переходов из состояния
    vector<map<char, int>> next;
    //суффиксные ссылки, максимальная длина, состояние с максимальной длинной, из которого пришли в текущее
    vector<int> link, len, p;
    int sz;

    SA() : sz(0) { node(); }

    int node() {
        next.emplace_back();
        link.emplace_back(-1);
        len.emplace_back(0);
        p.emplace_back(-1);
        return sz++;
    }

    int add(int A, char ch) {
        //создаем новое состояние
        int B = node();
        //суффиксная ссылка изначально в корень
        link[B] = 0;
        //длина нового состояния - длина предыдущего + 1
        len[B] = len[A] + 1;
        //родитель
        p[B] = A;
        //Пройдемся по суффиксам уже добавленной строки (родителя) и добавим переход по новой букве, если необходимо
        for (; A != -1; A = link[A]) {
            //если такого перехода нет просто направляем переход в текущее состояние
            if (next[A][ch] == 0) {
                next[A][ch] = B;
                continue;
            }
            //если такой переход есть, идем по нему
            int C = next[A][ch];
            //Если состояние с максимальной длинной из которого могли прийти в С то же состояние, в которое до этого пришли мы,
            //Направляем суффиксную ссылку в С и прерываем, так каак все остальные строки ведущие в С будут суффиксами того,
            //что вело из А и ничего не нарушится, для того состояния уже суфф ссылки посчитаны
            if (p[C] == A) {
                link[B] = C;
                break;
            }
            //Иначе существует более длинная строка ведущее в это же состояние, но она не является суффиксом текущей набранной,
            // от которой шли по ссылкам, предположим, что она является, но суфф ссылка ведет в более короткую, значит, где то уже было состояние, 
            //принимающее эту строку, но автомат детерминирован, поэтому не может принимать 2 разными путями отду строку. Поэтому 
            //делим ноду на 2, одна отвечает одному endpos, другая - другому. Причем более длинная строка меньшему endpos и она будет включаться
            //в endpos более кот=роткой, которую будем ассоциировать с новой вершиной, то есть из нее суфф ссылка теперь будет идти в новую ноду, 
            // как в ноду без какого-то первого символа
            //создаем новую ноду
            int D = node();
            //Копируем C в D, все переходы из состояния C в состояние D
            next[D] = next[C];
            //суффиксная ссылка из С копируется в D
            link[D] = link[C];
            //суффиксная ссылка из B и суффиксная ссылка из C ведут в D
            link[B] = link[C] = D;
            //длина состояния D это длина А, в которое пришли +1
            len[D] = len[A] + 1;
            //Минимально длинное состояние из которого пришли в D это А
            p[D] = A;
            //Продолжаем идти по суфф ссылкам А и перенаправляем все в D
            for (; A != -1 && next[A][ch] == C; A = link[A]) {
                next[A][ch] = D;
            }
            break;
        }
        return next[p[B]][ch];
    }
    bool find_pattern(string& pattern) {
        int cur_pos = 0;
        for (int i = 0; i < pattern.size(); ++i) {
            if (next[cur_pos].find(pattern[i]) == next[cur_pos].end()) {
                return false;
            }
            cur_pos = next[cur_pos][pattern[i]];
        }
        return true;
    }
};

int main() {
    SA a = SA();
    string s, pattern;
    int k, res=0;
    cin >> s;
    for (int i = 0; i < s.size(); ++i) {
        res = a.add(res, s[i]);
    }
    cin >> k;
    for (int i = 0; i < k; ++i) {
        cin >> pattern;
        bool res = a.find_pattern(pattern);
        if (res == true) {
            cout << "YES" << endl;
        }
        else {
            cout << "NO"<<endl;
        }
    }
}