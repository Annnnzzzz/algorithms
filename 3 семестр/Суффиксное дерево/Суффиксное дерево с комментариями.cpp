#include <bits/stdc++.h>
using namespace std;
struct State {
    // Вершина, на ребре в которую мы находимся.
    int v;
    // Отступ от начала ребра. Т.е. мы находимся в позиции l[v] + pos.
    int pos;
    State(int v, int pos) : v(v), pos(pos) {}
};

struct ST {
    // Переходов из вершины.
    vector<map<char, int>> next;
    // Cуфф ссылка, родитель.
    vector<int> link, par;
    // Полуинтервал строки для ребра ведущего в вершину v. Т.е. вершине v соответствует ребро со строкой s[l..r).
    vector<int> l, r;
    // Самый длинный суффикс строки, который не является листом в дереве будет лежать в ptr.
    State ptr;
    // Размер дерева.
    int sz;
    // Строка по которой строим дерево.
    string s;

    //есть ли переход из вершины v по символу c, если нет, добавляем фиктивный -1
    // и возвращаем для дальнейшего присваивания вершины после перехода
    int &get(int v, char c) {
        if (!next[v].count(c)) next[v][c] = -1;
        return next[v][c];
    }

    // Создаёт новую вершину.
    int node() {
        next.emplace_back();
        link.emplace_back(-1);
        par.emplace_back(-1);
        l.emplace_back(0);
        r.emplace_back(0);
        return sz++;
    }

    ST(string s) : ptr(0, 0), sz(0), s(s) {
        node();
        for (int i = 0; i < s.size(); ++i) add(i);
    }

    int len(int v) {
        return r[v] - l[v];
    }

    // Делает переход из состояния st по строке s[from, to)
    State go(State st, int from, int to) {
        while (from < to) {
            if (st.pos == len(st.v)) {
                // Мы оказались в вершине v и надо идти по следующему ребру.
                st = State(get(st.v, s[from]), 0);
                // Если такого перехода не существует вернём фиктивное состояние.
                if (st.v == -1) return st; //
            } else {
                // Мы находимся где-то на ребре в вершину v.
                // Если следующий символ не совпадает с символом s[from], значит мы не можем идти дальше по этому ребру.
                // Q: Почему мы сравниваем только первый символ, а не все s[from, to)?
                // A: Потому что мы используем go в двух случаях:
                //   1) Когда добавляем один новый символ в дерево. Тогда мы его честно проверим.
                //   2) Когда хотим пройти по уже существующему суффиксу (для поиска суфф. ссылки в suf_link(v)),
                //      но так как это продолжение было в вершине par[v], то оно также будет и в link[par[v]].
                if (s[l[st.v] + st.pos] != s[from]) return {-1, -1};
                // Если после прохода по s[from, to) мы останемся на этом же ребре, то вернём новое состояние.
                if (to - from < len(st.v) - st.pos) return {st.v, st.pos + to - from};
                // Иначе переместимся в вершину v, изменив from. На следующей итерации цикла получим новое ребро в if.
                from += len(st.v) - st.pos;
                st.pos = len(st.v);
            }
        }
        return st;
    }

    int split(State st) {
        // Если мы прошли всё ребро в v (стоим в v), то просто вернём v.
        if (st.pos == len(st.v)) return st.v;
        // Если мы не прошли ни одного шага на ребре в v, то мы стоим в par[v].
        if (st.pos == 0) return par[st.v];

        int cur = st.v;
        // Создаём новую вершину.
        int mid = node();
        // Меняем переходы. from par[cur] -> cur to par[cur] -> mid -> cur;
        get(par[cur], s[l[cur]]) = mid;
        get(mid, s[l[cur] + st.pos]) = cur;
        // Выставляем нужные границы полуинтервалов.
        l[mid] = l[cur];
        r[mid] = l[cur] + st.pos;
        l[cur] += st.pos;
        // Выставляем нужных родителей.
        par[mid] = par[cur];
        par[cur] = mid;
        return mid;
    }

    int get_link(int v) {
        // Если ссылка уже посчитана, то вернём её.
        if (link[v] != -1) return link[v];
        // Если мы в корне, то ссылка ведёт в корень.
        if (par[v] == -1) return 0;
        // Переходим по суфф ссылке нашего родителя (по ребру из которого мы прошли r[v] - l[v] символов).
        int to = get_link(par[v]);
        // Переходим от полученной вершины по такому же пути и делаем split в этом состоянии.
        // Note: Если мы в ребёнке корня, то нужно оторвать первый символ от строки s[l..r).
        return link[v] = split(go(State(to, len(to)), l[v] + (par[v] == 0), r[v]));
    }

    void add(int pos) {
        while (true) {
            // Проверяем, есть ли переход по новому символу из ptr.
            State nptr = go(ptr, pos, pos + 1);
            // Если есть, то ничего делать не надо, во всех суффиксах st тоже есть переход по этому символу.
            if (nptr.v != -1) {
                ptr = nptr;
                return;
            }
            // Если перехода не оказалось, то нам надо расщепить ребро в текущей позиции, подвесить лист и перейти по суфф ссылке.
            int mid = split(ptr);
            // Создаём лист.
            int leaf = node();
            // Лист всегда будет оставаться листом, при построении. Поэтому можем сразу продлить суффикс из него до s.size().
            l[leaf] = pos;
            r[leaf] = s.size();
            // Подвешиваем лист к текущей вершине
            par[leaf] = mid;
            get(mid, s[pos]) = leaf;

            // Переходим по суфф ссылке
            ptr.v = get_link(mid);
            ptr.pos = len(ptr.v);
            // Если оказались в корне, то заканчиваем.
            if (!mid) break;
        }
    }
};
